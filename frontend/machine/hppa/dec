
#line 1 "generated-code"
#include <assert.h>
#define sign_extend(N,SIZE) (((int)((N) << (sizeof(unsigned)*8-(SIZE)))) >> (sizeof(unsigned)*8-(SIZE)))

#line 1 "disassembler.m"
/*==============================================================================
 * FILE:     disassembler.m
 * OVERVIEW: Matcher file for a stand alone disassembler tool
 *
 (C) 2000-2001 The University of Queensland, BT group
 *============================================================================*/

#include "global.h"
#include "decoder.h"
#include "BinaryFile.h"

#include "hppa-names.h"

// globals
extern char _assembly[];
char aprefix[256];
char adata[256];
char* apre;
char* astr;
char *cmpltsep = ".";       // ??

// Prototypes
const char* GetSym(unsigned pc);
const char* GetReloc(unsigned pc);


#define ANAME       apre += sprintf( apre, "%s", name );
//#define APREF(x)    apre += sprintf( apre, "%s", x );
//#define AARGs(x)    astr += sprintf( astr, "%s", x );
//#define AARGd(x)    astr += sprintf( astr, "%d", x );
//#define AARGf(f, x) astr += sprintf( astr, " ## f ## ", x );
//#define Acom        astr += sprintf( astr, "," );
#define CONS(x)     strcat(constrName, x);
#define IGNORE(x)   not_used(*(int*)&x);

// The below is used to quelch annoying "variable not used" warnings
void not_used(int unwanted)
{
    unwanted = 0;
}

DWord getDword (unsigned lc)
/* get4Bytes - returns next 4-Byte from image pointed to by lc.
   Fetch in a big-endian manner  */
{
    return
      (DWord)
      ((((((
          *(Byte *)lc << 8
      ) + *(Byte *)(lc+1)) << 8
      ) + *(Byte *)(lc+2)) << 8
      ) + *(Byte *)(lc+3));
}

static char killBuffer[32];

// Find and kill any dots in the opcode name (and all chars thereafter)
char* killDot(char* str)
{
    strcpy(killBuffer, str);
    char* p = strchr(killBuffer, '.');
    if (p) *p = '\0';
    return killBuffer;
}

static char shexBuffer[32];

char* signedHex(int disp)
{
    if (disp < 0)
        sprintf(shexBuffer, "-0x%x", -disp);
    else
        sprintf(shexBuffer, "0x%x", disp);
    return shexBuffer;
}

// This function returns 0 or 8; the 8 is to access the last half of arrays
// of conditions (e.g. CMPIBF, or the "f" bit of ariths)
int dis_c_c_n(ADDRESS hostpc)
{
    int result = 0;


#line 101 "generated-code"

