#!/bin/sh
#
# This script is a wrapper to simplify generating decoders from .spec files
# and a .m file.
#
# Copyright (C) 2000-2001, The University of Queensland
# Copyright (C) 2000, Sun Microsystems, Inc
# Copyright (C) 2017, Kyle Guinn
#
# See the file "LICENSE.TERMS" for information on usage and redistribution of
# this file, and for a DISCLAIMER OF ALL WARRANTIES.


# These 2 tools are configured (see configure.ac)
SML_TOOLKIT=@SML_TOOLKIT@
UNGENERATE=@UNGENERATE@

usage () {
	echo "usage: $0 matcher-file [-o output.cpp] [spec-files]"
	exit 2
}

# Determine matcher filename.
if [ $# -lt 1 ]; then
	usage
fi
MATCHER="$1"
shift

# Determine output filename.
if [ $# -eq 1 -a "$1" = "-o" ]; then
	usage
elif [ $# -ge 2 -a "$1" = "-o" ]; then
	OUTPUT="$2"
	shift 2
else
	# Derive the output filename from the matcher.
	OUTPUT="$(dirname "${MATCHER}")/$(basename "${MATCHER}" .m).cpp"
fi

# Build the list of spec files.
SPECS=
if [ $# -gt 0 ]; then
	SPECS="\"$1\""
	shift
fi
while [ $# -gt 0 ]; do
	SPECS="${SPECS}, \"$1\""
	shift
done

# Run the toolkit.
# Norman wrote some 32 bit code for us, at great time expense to him, but
# unfortunately, this seems to cause a memory explosion. The versions from
# 4th Aug onwards have this problem. So for now, we use the 1st Aug version,
# which doesn't have the 32 bit fixes, and we turn off the field fusion
# optimisations (so it doesn't need the 32 bit code to match single sparc
# return instructions, for example).
eval "${SML_TOOLKIT}" <<EOF
	val _ = GlobalState.Match.fuse := false;
	val d = CC.matcher[${SPECS}];
	d "${MATCHER}";
EOF
if [ ! -f "${MATCHER}.d" ]; then
	exit 1;
fi

# Clean up the toolkit output and rename it.
${UNGENERATE} "${MATCHER}.d"
cat "${MATCHER}.d" | awk '
	/#line.*decoder\.m"/ {
		line = $2;
		print $1 " " (line-1) " " $3;
		next;
	}
	{
		gsub(/\(char \*\)0/, "nullptr");
		sub(/char \*MATCH_name/, "const &");
		sub(/char \*name = MATCH_name;/, "const &");
		print;
	}' > "${OUTPUT}"
rm "${MATCHER}.d"
